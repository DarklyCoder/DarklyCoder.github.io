title: Android-搭建OpenCV开发环境
date: 2016-05-09 22:43:37
categories:
    - Android
tags:
    - Android
    - OpenCV
---

### 搭建OpenCV开发环境

* 下载[OpenCV for Android](http://opencv.org/)。
* 解压文件。samples目录下是样例代码，sdk目录下是我们需要用到的java层和jni层的代码，apk目录是manager的apk安装包。
<!-- more -->

　　其实OpenCV最简单的使用方式是使用manager，也就是使用apk目录下的安装包，安装对应的apk，将java层代码导入，使用`OpenCVLoader.initAsync()`加载库，之后你就可以直接用java代码调用Opencv相关的功能了。但是这种方式除了安装我们自己的apk还需要安装上面提到的manager的apk，用户体验十分不好，不推荐使用。下面介绍另外三种使用方式将完全脱离这个manager的apk。

#### 前期准备

1. 首先新建一个项目，将OpenCV中sdk目录下的native目录拷到项目根目录。
<div align=center>
    <img src="http://www.sxt.cn/editor/attached/image/20151101/714238790/24e8a753-59ad-4940-9331-22e7184c3b0a.jpg">
</div>

2. 新建jni目录，在里面新建两个文件:Android.mk和Application.mk。
<div align=center>
    <img src="http://www.sxt.cn/editor/attached/image/20151101/714238790/83240985-6d24-462c-9c86-4415f638c5ff.jpg">
    <img src="http://www.sxt.cn/editor/attached/image/20151101/714238790/bebd51c8-3665-4159-91c7-86dd7da918e4.jpg">
</div>

3. 编辑`gradle.properties`文件，增加下面的属性使用旧版的ndk功能（不添加会使用实验性的ndk构建工具）

        android.useDeprecatedNdk=true

4. 编辑`local.properties`文件中配置ndk目录

        ndk.dir="换成你自己的NDK路径"

5. 编辑`build.gradle`，在android节点中增加下面的代码

        sourceSets.main.jni.srcDirs = []
        //禁止自带的ndk功能
        sourceSets.main.jniLibs.srcDirs = ['src/main/libs','src/main/jniLibs']
        //重定向so目录为src/main/libs和src/main/jniLibs，原来为src/main/jniLibs

        task ndkBuild(type: Exec, description: 'Compile JNI source with NDK') {
            Properties properties = new Properties()
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            def ndkDir = properties.getProperty('ndk.dir')

            if (org.apache.tools.ant.taskdefs.condition.Os.isFamily(org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS)) {
                commandLine "$ndkDir/ndk-build.cmd", '-C', file('src/main/jni').absolutePath
            } else {
                commandLine "$ndkDir/ndk-build", '-C', file('src/main/jni').absolutePath
            }
        }

        tasks.withType(JavaCompile) {
            compileTask -> compileTask.dependsOn ndkBuild
        }

        task ndkClean(type: Exec, description: 'Clean NDK Binaries') {
            Properties properties = new Properties()
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            def ndkDir = properties.getProperty('ndk.dir')

            if (org.apache.tools.ant.taskdefs.condition.Os.isFamily(org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS)) {
                commandLine "$ndkDir/ndk-build.cmd",'clean', '-C', file('src/main/jni').absolutePath
            } else {
                commandLine "$ndkDir/ndk-build",'clean', '-C', file('src/main/jni').absolutePath
            }
        }

        clean.dependsOn 'ndkClean'

6. 在之前新建的Application.mk中增加下面的内容

        APP_STL := gnustl_static
        APP_CPPFLAGS := -frtti -fexceptions
        APP_ABI := armeabi armeabi-v7a
        APP_PLATFORM := android-8

7. 在Android.mk中增加下面的内容

        LOCAL_PATH := $(call my-dir)
        include $(CLEAR_VARS)

        OpenCV_INSTALL_MODULES := on
        OpenCV_CAMERA_MODULES := off

        OPENCV_LIB_TYPE :=STATIC

        ifeq ("$(wildcard $(OPENCV_MK_PATH))","")
        include ..\..\..\..\native\jni\OpenCV.mk #注意替换路径
        else
        include $(OPENCV_MK_PATH)
        endif

        LOCAL_MODULE := OpenCV
        LOCAL_SRC_FILES :=
        LOCAL_LDLIBS +=  -lm -llog

        include $(BUILD_SHARED_LIBRARY)

这时候，使用gradle构建一下，如果能成功构建出so，说明配置没问题，如下图，点击as右侧的gradle展开，双击ndkBuild进行构建
<div align=center>
    <img src="http://www.sxt.cn/editor/attached/image/20151101/714238790/0adcd150-b368-45f3-bc61-cdf9db62625d.jpg">
</div>

#### 使用静态的OpenCV库的方式

* 声明java层的native方法

        public class OpenCVHelper {

            static {
                System.loadLibrary("OpenCV");
            }

            public static native int[] gray(int[] buf, int w, int h);
        }

* 使用javah命令生成头文件'javah -jni com.zqy.opencvdemo.OpenCVHelper'

        /* DO NOT EDIT THIS FILE - it is machine generated */
        #include <jni.h>
        /* Header for class com_zqy_opencvdemo_OpenCVHelper */

        #ifndef _Included_com_zqy_opencvdemo_OpenCVHelper
        #define _Included_com_zqy_opencvdemo_OpenCVHelper
        #ifdef __cplusplus
        extern "C" {
        #endif
        /*
         + Class:     com_zqy_opencvdemo_OpenCVHelper
         + Method:    gray
         + Signature: ([III)[I
         */
        JNIEXPORT jintArray JNICALL Java_com_zqy_opencvdemo_OpenCVHelper_gray
          (JNIEnv *, jclass, jintArray, jint, jint);

        #ifdef __cplusplus
        }
        #endif
        #endif

* 新建cpp文件，实现对应的方法，就是灰度处理

        #include "com_zqy_opencvdemo_OpenCVHelper.h"
        #include <stdio.h>
        #include <stdlib.h>
        #include <opencv2/opencv.hpp>

        using namespace cv;

        extern "C" {

        JNIEXPORT jintArray JNICALL Java_com_zqy_opencvdemo_OpenCVHelper_gray(
                JNIEnv *env, jclass obj, jintArray buf, int w, int h);

        JNIEXPORT jintArray JNICALL Java_com_zqy_opencvdemo_OpenCVHelper_gray(
                JNIEnv *env, jclass obj, jintArray buf, int w, int h) {

            jint *cbuf;
            cbuf = env->GetIntArrayElements(buf, JNI_FALSE );
            if (cbuf == NULL) {
                return 0;
            }

            Mat imgData(h, w, CV_8UC4, (unsigned char *) cbuf);

            uchar* ptr = imgData.ptr(0);
            for(int i = 0; i < w*h; i ++){
                //计算公式：Y(亮度) = 0.299*R + 0.587*G + 0.114*B
                //对于一个int四字节，其彩色值存储方式为：BGRA
                int grayScale = (int)(ptr[4*i+2]*0.299 + ptr[4*i+1]*0.587 + ptr[4*i+0]*0.114);
                ptr[4*i+1] = grayScale;
                ptr[4*i+2] = grayScale;
                ptr[4*i+0] = grayScale;
            }

            int size = w * h;
            jintArray result = env->NewIntArray(size);
            env->SetIntArrayRegion(result, 0, size, cbuf);
            env->ReleaseIntArrayElements(buf, cbuf, 0);
            return result;
        }
        }

* 之后，需要将cpp文件编译进去，在Andorid.mk文件中加入

        LOCAL_SRC_FILES := com_zqy_opencvdemo_OpenCVHelper.cpp

* 然后在java层写个测试方法测试一下是否进行灰度化了

        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);
        int w = bitmap.getWidth(), h = bitmap.getHeight();
        int[] pix = new int[w * h];
        bitmap.getPixels(pix, 0, w, 0, 0, w, h);
        int[] resultPixes = OpenCVHelper.gray(pix, w, h);
        Bitmap result = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
        result.setPixels(resultPixes, 0, w, 0, 0, w, h);
        imageView.setImageBitmap(result);

#### 使用动态的OpenCV库的方式

* 在第一种基础上，修改Android.mk文件,修改`OPENCV_LIB_TYPE := STATIC`为`OPENCV_LIB_TYPE := SHARED`。这时候再用ndkBuild一下，你会发现会输出一些警告以及一部分红色的内容。生成的so库的大小为310k，小了好几倍。这时候如果你直接运行程序，会报错误，原因是我们使用的是动态库加载方式，还需要将依赖的so加进去，这个so就是图中的`libopencv_java3.so`，它在我们的最开始加到项目里的native目录中，将它按需拷到我们的jniLibs目录中去，既然我们使用了动态链接库，那么我们同样也可以使用java层的接口，优点是java开发速度相对快一点。

#### 同时使用Java的API又使用JNI的接口的方式，此时编译时一般使用的是动态链接OpenCV库的方式。

* 在第一种基础上，我们需要将sdk目录中的java代码拷到项目中去，但是`org.opencv.engine`包中是一个`aidl`，我们需要将它剪贴到aidl目录中去，最后还有一个资源文件attrs.xml，copy过来,build一下项目，不出意外应该会报错，这时候找到该类，引入自己的R文件包就可以了,再次build应该就不会有什么问题了。

* java层的测试方法

        OpenCVLoader.initDebug();
        Mat rgbMat = new Mat();
        Mat grayMat = new Mat();
        Bitmap srcBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);
        Bitmap grayBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), Bitmap.Config.RGB_565);
        Utils.bitmapToMat(srcBitmap, rgbMat);//convert original bitmap to Mat, R G B.
        Imgproc.cvtColor(rgbMat, grayMat, Imgproc.COLOR_RGB2GRAY);//rgbMat to gray grayMat
        Utils.matToBitmap(grayMat, grayBitmap); //convert mat to bitmap
        imageView.setImageBitmap(grayBitmap);

　　注意使用`OpenCVLoader.initDebug();`进行初始化而不是使用`OpenCVLoader.initAsync()`。这种方法的特点是处理都在java层，不怎么会涉及jni层的代码，除非java层完成不了的工作会转移到jni层去。

三种方法各有各的优点，根据自己的情况进行选择：

* 如果c++特别好的，建议使用第一种方法
* 如果更习惯java代码的，并且java层的函数都能进行处理的，建议选择第三种方法
* 第二种方法建议在第三种方法不满足条件的情况下进行辅助使用，因为使用了第三种方法的前提是使用第二种方法的动态链接库。
